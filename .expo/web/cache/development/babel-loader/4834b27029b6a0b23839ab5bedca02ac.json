{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.get = get;\nexports.getEnforcing = getEnforcing;\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar NativeModules = require('../BatchedBridge/NativeModules');\n\nvar turboModuleProxy = global.__turboModuleProxy;\n\nfunction requireModule(name) {\n  if (!global.RN$Bridgeless) {\n    var legacyModule = NativeModules[name];\n\n    if (legacyModule != null) {\n      return legacyModule;\n    }\n  }\n\n  if (turboModuleProxy != null) {\n    var module = turboModuleProxy(name);\n\n    if (module == null) {\n      console.info('Unable to get TurboModule for ' + name + '. Safe to ignore if module works.');\n    }\n\n    return module;\n  }\n\n  return null;\n}\n\nfunction get(name) {\n  return requireModule(name);\n}\n\nfunction getEnforcing(name) {\n  var module = requireModule(name);\n  (0, _invariant.default)(module != null, \"TurboModuleRegistry.getEnforcing(...): '\" + name + \"' could not be found. \" + 'Verify that a module by this name is registered in the native binary.');\n  return module;\n}","map":{"version":3,"sources":["C:/Users/Anonymous/project1/node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"],"names":["NativeModules","require","turboModuleProxy","global","__turboModuleProxy","requireModule","name","RN$Bridgeless","legacyModule","module","console","info","get","getEnforcing"],"mappings":";;;;;;;;AAYA;;AAFA,IAAMA,aAAa,GAAGC,OAAO,CAAC,gCAAD,CAA7B;;AAIA,IAAMC,gBAAgB,GAAGC,MAAM,CAACC,kBAAhC;;AAEA,SAASC,aAAT,CAAuCC,IAAvC,EAAyD;AAEvD,MAAI,CAACH,MAAM,CAACI,aAAZ,EAA2B;AAEzB,QAAMC,YAAY,GAAGR,aAAa,CAACM,IAAD,CAAlC;;AACA,QAAIE,YAAY,IAAI,IAApB,EAA0B;AACxB,aAASA,YAAT;AACD;AACF;;AAED,MAAIN,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,QAAMO,MAAU,GAAGP,gBAAgB,CAACI,IAAD,CAAnC;;AACA,QAAIG,MAAM,IAAI,IAAd,EAAoB;AAGlBC,MAAAA,OAAO,CAACC,IAAR,CACE,mCACEL,IADF,GAEE,mCAHJ;AAKD;;AACD,WAAOG,MAAP;AACD;;AAED,SAAO,IAAP;AACD;;AAEM,SAASG,GAAT,CAA6BN,IAA7B,EAA+C;AACpD,SAAOD,aAAa,CAAIC,IAAJ,CAApB;AACD;;AAEM,SAASO,YAAT,CAAsCP,IAAtC,EAAuD;AAC5D,MAAMG,MAAM,GAAGJ,aAAa,CAAIC,IAAJ,CAA5B;AACA,0BACEG,MAAM,IAAI,IADZ,EAEE,6CAA2CH,IAA3C,8BACE,uEAHJ;AAKA,SAAOG,MAAP;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nconst NativeModules = require('../BatchedBridge/NativeModules');\nimport type {TurboModule} from './RCTExport';\nimport invariant from 'invariant';\n\nconst turboModuleProxy = global.__turboModuleProxy;\n\nfunction requireModule<T: TurboModule>(name: string): ?T {\n  // Bridgeless mode requires TurboModules\n  if (!global.RN$Bridgeless) {\n    // Backward compatibility layer during migration.\n    const legacyModule = NativeModules[name];\n    if (legacyModule != null) {\n      return ((legacyModule: $FlowFixMe): T);\n    }\n  }\n\n  if (turboModuleProxy != null) {\n    const module: ?T = turboModuleProxy(name);\n    if (module == null) {\n      // Common fixes: Verify the TurboModule is registered in the native binary, and adopts the code generated type-safe Spec base class.\n      // Safe to ignore when caused by importing legacy modules that are unused.\n      console.info(\n        'Unable to get TurboModule for ' +\n          name +\n          '. Safe to ignore if module works.',\n      );\n    }\n    return module;\n  }\n\n  return null;\n}\n\nexport function get<T: TurboModule>(name: string): ?T {\n  return requireModule<T>(name);\n}\n\nexport function getEnforcing<T: TurboModule>(name: string): T {\n  const module = requireModule<T>(name);\n  invariant(\n    module != null,\n    `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` +\n      'Verify that a module by this name is registered in the native binary.',\n  );\n  return module;\n}\n"]},"metadata":{},"sourceType":"script"}